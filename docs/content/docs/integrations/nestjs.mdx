---
title: NestJS Integration
description: Integrate Better Auth with NestJS.
---

This guide shows you how to integrate Better Auth with [NestJS](https://nestjs.com/).

Before you start, make sure you have:
- A working NestJS application
- Better Auth installed and configured ([installation guide](/docs/installation))

## Basic Setup

**1. Disable Body Parser**

Disable NestJS's built-in body parser to allow Better Auth to handle the raw request body:

```ts title="main.ts"
import { NestFactory } from "@nestjs/core";
import { AppModule } from "./app.module";

async function bootstrap() {
  const app = await NestFactory.create(AppModule, {
    bodyParser: false,
  });
  await app.listen(process.env.PORT ?? 3333);
}
bootstrap();
```

<Callout type="warn">
Currently, Better Auth's NestJS integration **only supports Express** and does not work with Fastify.
</Callout>

**2. Import AuthModule**

Import the `AuthModule` in your root module:

```ts title="app.module.ts"
import { Module } from '@nestjs/common';
import { AuthModule } from 'better-auth/nestjs';
import { auth } from "./auth";

@Module({
  imports: [
    AuthModule.forRoot(auth),
  ],
})
export class AppModule {}
```

This will automatically:
- Mount the Better Auth handler at `/api/auth/*`
- Set up proper CORS configuration
- Configure session handling

## Advanced Module Configuration with forRootAsync

For more complex setups where you need to inject dependencies or load configuration asynchronously, use the `forRootAsync` method:

```ts title="app.module.ts"
import { Module } from '@nestjs/common';
import { AuthModule } from 'better-auth/nestjs';
import { ConfigModule, ConfigService } from '@nestjs/config';
import { auth } from './auth';

@Module({
  imports: [
    ConfigModule.forRoot(),
    AuthModule.forRootAsync({
      imports: [ConfigModule],
      inject: [ConfigService],
      useFactory: (configService: ConfigService) => ({
        auth: auth.withOptions({
          basePath: configService.get('AUTH_BASE_PATH', '/api/auth'),
          session: {
            cookieName: configService.get('AUTH_COOKIE_NAME', 'auth-session'),
            cookieOptions: {
              secure: configService.get('NODE_ENV') === 'production',
            },
          },
        }),
      }),
    }),
  ],
})
export class AppModule {}
```

### forRootAsync Options

The `forRootAsync` method accepts the following options:

- **imports**: An array of modules to import, whose providers can be injected into the `useFactory` function
- **inject**: An array of providers to inject into the `useFactory` function
- **useFactory**: A factory function that returns the auth configuration options

### Use Cases for forRootAsync

**1. Environment-specific Configuration**

Load different configuration based on the environment:

```ts
AuthModule.forRootAsync({
  imports: [ConfigModule],
  inject: [ConfigService],
  useFactory: (configService: ConfigService) => {
    const isDev = configService.get('NODE_ENV') !== 'production';
    
    return {
      auth: auth.withOptions({
        basePath: configService.get('AUTH_BASE_PATH', '/api/auth'),
        session: {
          cookieOptions: {
            secure: !isDev,
            sameSite: isDev ? 'lax' : 'none',
          },
        },
      }),
    };
  },
}),
```

**2. Database Integration**

Configure Better Auth to use a database with proper dependency injection:

```ts
AuthModule.forRootAsync({
  imports: [DatabaseModule],
  inject: [DbService],
  useFactory: (dbService: DbService) => ({
    auth: auth.withAdapter({
      adapter: createCustomAdapter(dbService),
    }),
  }),
}),
```

**3. Multiple Service Dependencies**

Inject multiple services for complex configuration:

```ts
AuthModule.forRootAsync({
  imports: [ConfigModule, LoggerModule, CacheModule],
  inject: [ConfigService, LoggerService, CacheService],
  useFactory: (
    configService: ConfigService, 
    loggerService: LoggerService,
    cacheService: CacheService
  ) => ({
    auth: auth.withOptions({
      basePath: configService.get('AUTH_BASE_PATH'),
      logger: loggerService,
      cache: cacheService,
    }),
  }),
}),
```

## Route Protection

Better Auth provides an `AuthGuard` to protect your routes. You can apply it in two ways:

**1. Controller or Route Level**

Apply the guard to specific controllers or routes:

```ts title="app.controller.ts"
import { Controller, Get, UseGuards } from '@nestjs/common';
import { AuthGuard, Session, UserSession, Public, Optional } from 'better-auth/nestjs';

@Controller('users')
@UseGuards(AuthGuard) // Apply to all routes in this controller
export class UserController {
  @Get('me')
  async getProfile(@Session() session: UserSession) {
    return session;
  }

  @Get('public')
  @Public() // Mark this route as public (no authentication required)
  async publicRoute() {
    return { message: "This route is public" };
  }

  @Get('optional')
  @Optional() // Authentication is optional for this route
  async optionalRoute(@Session() session: UserSession) {
    return { authenticated: !!session, session };
  }
}
```

**2. Global Registration**

Register the guard globally using `APP_GUARD`:

```ts title="app.module.ts"
import { Module } from '@nestjs/common';
import { APP_GUARD } from '@nestjs/core';
import { AuthModule, AuthGuard } from 'better-auth/nestjs';
import { auth } from "./auth";

@Module({
  imports: [
    AuthModule.forRoot(auth),
  ],
  providers: [
    {
      provide: APP_GUARD,
      useClass: AuthGuard,
    },
  ],
})
export class AppModule {}
```

With global registration, all routes will require authentication by default. Use the `@Public()` decorator to mark routes that don't require authentication.

## User Sessions

Access the user session in your controllers using the `Session` decorator:

```ts title="user.controller.ts"
import { Controller, Get } from '@nestjs/common';
import { Session, UserSession } from 'better-auth/nestjs';

@Controller('users')
export class UserController {
  @Get('me')
  async getProfile(@Session() session: UserSession) {
    return session;
  }
}
```

You can also access the session through the request object:

```ts
import { Controller, Get, Request } from '@nestjs/common';
import type { Request as ExpressRequest } from 'express';

@Controller('users')
export class UserController {
  @Get('me')
  async getProfile(@Request() req: ExpressRequest) {
    return req.session; // Session is attached to the request
  }
}
```

## Custom Hooks

Create custom hooks that integrate with NestJS's dependency injection:

```ts title="hooks/sign-up.hook.ts"
import { Injectable } from "@nestjs/common";
import { BeforeHook, AuthContext } from "better-auth/nestjs";
import { SignUpService } from "./sign-up.service";

@Injectable()
export class SignUpHook {
    constructor(private readonly signUpService: SignUpService) {}

    @BeforeHook('/sign-up/email')
    async handle(ctx: AuthContext) {
        // Custom logic like enforcing email domain registration
        // Can throw APIError if validation fails
        await this.signUpService.execute(ctx);
    }
}
```

Register your hooks in a module:

```ts title="auth/auth.module.ts"
import { Module } from '@nestjs/common';
import { SignUpHook } from './hooks/sign-up.hook';
import { SignUpService } from './sign-up.service';

@Module({
  providers: [SignUpHook, SignUpService],
})
export class AuthModule {}
```

## Database Adapters

### Using Prisma with Better Auth

Use the `forRootAsync` method to integrate your PrismaService with Better Auth:

```ts title="app.module.ts"
import { Module } from '@nestjs/common';
import { AuthModule } from 'better-auth/nestjs';
import { PrismaService } from './prisma/prisma.service';
import { PrismaModule } from './prisma/prisma.module';
import { createPrismaAdapter } from 'better-auth/prisma';
import { auth } from './auth';

@Module({
  imports: [
    PrismaModule,
    AuthModule.forRootAsync({
      imports: [PrismaModule], // Import the module that provides PrismaService
      inject: [PrismaService],
      useFactory: (prisma: PrismaService) => ({
        auth: auth.withAdapter({
          adapter: createPrismaAdapter({
            prisma,
            // Additional adapter configuration options
            userTable: 'user',
            sessionTable: 'session',
          }),
        }),
      }),
    }),
  ],
})
export class AppModule {}
```

Create a separate module for Prisma to ensure proper dependency management:

```ts title="prisma/prisma.module.ts"
import { Module, Global } from '@nestjs/common';
import { PrismaService } from './prisma.service';

@Global()
@Module({
  providers: [PrismaService],
  exports: [PrismaService],
})
export class PrismaModule {}
```

With this setup, Better Auth will automatically work with your Prisma database, handling all user authentication flows while maintaining type-safety and proper dependency injection according to NestJS best practices.
